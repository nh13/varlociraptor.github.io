+++
title = "Calling variants"
weight = 2
+++

Varlociraptor allows to call small and structural variant events in different scenarios.
Note that varlociraptor requires to provide a set of candidate variants to consider.
By this, our model becomes independent of denovo variant detection mechanisms and can be combined with any caller (e.g. GATK, Freebayes, Delly, ...). In particular, you can also first combine candidates from different callers, to cover diverse variant types and length ranges.
Let `candidates.bcf` be the set of candidate variant calls (VCF or BCF format, see [bcftools](https://samtools.github.io/bcftools/)).
Let `reference.fa` be the reference genome FASTA file (indexed with [samtools](https://www.htslib.org/doc/samtools.html)).

## Preprocessing per-sample observations

First, varlociraptor requires to preprocess the candidate variants in order to obtain per-sample observations for the actual calling process.
Let `sample.bam` be the aligned reads of the sample to preprocess.
While varlociraptor does not require a particular read aligner, it assumes that provided mapping qualities (MAPQ) are as accurate as possible, and that too large indels are encoded as softclips (i.e. it expects BAMs in [bwa mem](https://bio-bwa.sourceforge.net/) style).
Preprocessing can be started with

```bash
varlociraptor preprocess variants reference.fa --bam sample.bam < candidates.bcf > sample.observations.bcf
```

In other words, the candidate variants are piped into varlociraptor (with the `<` shell operator) and observations are piped into `sample.observations.bcf` (with the `>` shell operator).

Note that the candidate variants (here ``candidates.bcf``) have to be **the same for each sample**.
This can be achieved by either jointly calling across all samples (as possible with most variant callers), or by merging candidates from all involved samples into a single VCF/BCF file.
From the candidate variant file, only `CHROM`, `POS`, `REF`, `ALT`, `EVENT` (in case of breakends), `END`, and `SVLEN` (if present) are used. Other fields are ignored.
Variant types that are not (yet) supported by Varlociraptor will be dropped (with notification on STDERR).

### Parallelization

Instead of offering internal parallelization, ``varlociraptor preprocess variants`` should be parallelized via a scatter-gather.
That means that you first split the ``candidates.bcf`` into chunks of equal size.
This can best be done via Rust-Bio-Tools (``rbt``), which offers a subcommand for splitting VCF/BCF files while properly handling events that span multiple records (breakend events with ``SVTYPE=BND``).
For example, with

```bash
rbt vcf-split candidates.bcf chunk{0..15}.bcf
```

the ``candidates.bcf`` is splitted into 16 chunks of approximately equal size.
After applying ``varlociraptor preprocess variants`` and also the calling steps described below (and, depending on the research question, a variant annotation tool like VEP), the processed chunks can be merged again.

If the input candidates did contain breakend variants (``SVTYPE=BND``, which only happens when generated by structural variant callers), they have to be sorted first e.g., via ``bcftools sort``.
Merging can happen via ``bcftools concat``.

### Fast mode

Preprocessing is the most time-intensive part for variant calling with varlociraptor.
However, it only has to be done once for each sample, and can be re-used for different variant calling steps.
In case the exact allele frequency is less important for you (e.g. with large cohorts), you can add the argument ``--pairhmm-mode fast``.
This will approximate the pair HMM computation of Varlociraptor by just considering the optimal alignment path, thereby changing the computation of the allele likelihoods from quadratic to linear.
In rare cases this can lead to wrong probabilities for single reads though, such that allele frequencies can become slightly incorrect.

## Calling

The basic calling command is

```bash
varlociraptor call variants ...
```

The dots (`...`) refer to the selected calling mode, which can be one of the following:

1. **Tumor-normal variant calling:** this assumes that a tumor and a corresponding healthy sample is given.
2. **Generic variant calling:** via a *variant calling grammar*, arbitrary calling scenarios can be defined.

## Tumor-normal variant calling

Let `tumor.bcf` and `normal.bcf` be the preprocessed observations (see above) of the tumor and healthy/normal sample, respectively.
Then, variants of all lengths can be called with

```bash
varlociraptor call variants tumor-normal --purity 0.75 --tumor tumor.bcf --normal normal.bcf > calls.bcf
```

with `0.75` being the purity (i.e. the cancer cell content) of the tumor sample.
The result is a proper stastistical assessment of the somatic and germline variants, without the need to apply any ad-hoc filtering.
Instead, it should be followed by controlling the false discovery rate over the desired events, see [Filtering]({{< ref "filtering.md" >}}).

## Generic variant calling

The generic mode allows to define a calling scenario via a variant calling grammar.
The grammar allows to define the desired scenario in a [YAML](https://yaml.org) file.
For example, the following defines a normal/tumor/relapse model (i.e., joint calling of tumor and relapse after therapy against normal):

```yaml
samples:
  normal:
    resolution: 5
    universe: "0.0 | 0.5 | 1.0 | ]0.0,0.5["
  tumor:
    resolution: 100
    universe: "[0.0,1.0]"
    contamination:
      by: normal
      fraction: 0.25
  relapse:
    resolution: 100
    universe: "[0.0,1.0]"
    contamination:
      by: normal
      fraction: 0.53

events:
  germline:        "normal:0.5 | normal:1.0"
  somatic_normal:  "normal:]0.0,0.5["
  somatic_tumor:   "normal:0.0 & tumor:]0.0,1.0]"
  somatic_relapse: "normal:0.0 & tumor:0.0 & relapse:]0.0,1.0]"
```

In the following, we briefly describe each element for the grammar.

* `samples`: this section contains the definition of the involved samples. Each sample is listed by its name (e.g. `normal`) which is referred to later in the `events` section.
* `resolution`: the number of points in allele frequency space to evaluate when integrating over continuous allele frequency intervals (e.g. `]0.0,0.5[`). A resolution of 100 in an allele frequency interval of `]0.0,1.0[` means that allele frequency is evaluated in steps of size `0.01`.
* `universe`: valid allele frequencies in the given sample. The operator `|` denotes a logical "or". For example `0.0 | 0.5 | 1.0 | ]0.0,0.5[` means that an allele frequency of `0.0`, `0.5`, `1.0` or any frequency in the interval `]0.0,0.5[` (with exlcusive bounds) is possible for the particular sample.
* `contamination`: denotes the contamination of the sample with another sample, given by its name after the `by` key, and the fraction of contamination after the `fraction` key.
* `events`: this section contains the definition of events that shall be evaluated. Each event is a boolean logic formula over operands that define allele frequencies or allele frequency intervals in particular samples. These operands have the form `samplename:spec`, where spec is the specification of an allele frequency (e.g. `0.5`) or an allele frequency interval (inclusive: `[a,b]`, left-exclusive: `]a,b]`, right-exclusive: `[a,b[`, exclusive: `]a,b[`).
* `expressions`: analogous to `events`, expressions allow to define formulas, each with a given name. However, expressions are by default ignored, and have to be explicitly used from within `events` formulae. For example, let `myexpr` be the name of an expression, then it can be used in any formula by specifying `$myexpr`.

For each variant, Valrociraptor will calculate the probability of each defined event to be true.
Importantly, for proper results, the given events have to **cover the entire range of possibilities**. 
Otherwise, the calculated posterior probabilities would be biased.
The absent event (i.e. here `tumor:0.0 & normal:0.0 & relapse:0.0`) is added implicitly though.

Let `scenario.yaml` be the defined calling scenario (e.g., as above).
Let `relapse.bcf`, `tumor.bcf`, and `normal.bcf` be the preprocessed observations of relapse, tumor and healthy/normal sample, respectively, as defined above.
Then, the calling command would be

```bash
varlociraptor call variants generic --scenario scenario.yaml --obs relapse=relapse.sorted.bcf tumor=tumor.bcf normal=normal.bam > calls.bcf
```

Note that now, observation files are given with a leading name, which has to correspond to the name defined in the scenario YAML.
The result is a proper stastistical assessment of the desired scenario, without the need to apply any ad-hoc filtering.
Instead, it should be followed by controlling the false discovery rate over the desired events, see [Filtering]({{< ref "filtering.md" >}}).

### Grammar applications

#### Single sample germline calling

The probably most simple case is the calling of germline variants in a single sample (let us say the sample is called `hamlet`):

```yaml
samples:
  hamlet:
    resolution: 5
    universe: "0.0 | 0.5 | 1.0"

events:
  het: "0.5"
  hom: "1.0"
```

The resolution key (see above) is actually superfluous in this case, as there is no continous allele frequency interval involved.
Future releases of Varlociraptor will allow to omit it.
In order to make this model more exact, please refer to "Chromosome specific allele frequency universes" below.

#### Single sample tumor-only calling

When having only a single tumor sample with known contamination by normal cells but without a separately sequenced normal sample, it is possible to make use of Varlociraptor's ability to nevertheless properly model the contamination:

```yaml
samples:
  normal:
    resolution: 5
    universe: "0.0 | 0.5 | 1.0"
  tumor:
    resolution: 100
    universe: "[0.0,1.0]"
    contamination:
      by: normal
      fraction: 0.25

events:
  somatic:  "normal:0.0 & tumor:]0.0,1.0]"
  germline: "normal:0.5 | normal:1.0"
```

With such a scenario, even when no aligned reads from a separate normal sample are provided, Varlociraptor can still calculate the probabilities for the defined events.
Naturally, whenever the observed reads do not allow to decide, both probabilities will become accordingly weak.
This is e.g. the case for an observed allele frequency of 0.5, which in this scenario can be either a somatic variant with allele frequency 1/3, or a heterozygous germline variant.
If the observed allele frequency is 1.0 though, it is clear that the variant has to be germline, since a somatic variant could occur at a frequency of 0.75 at most (because of the contamination).
Similarly, an observed allele frequency far away from 0.5 and 1.0 indicates a tendency towards a somatic variant, which will again be properly reflected in the event probabilities.

#### Chromosome specific allele frequency universes

Certain chromosomes differ from the overall ploidy of an organism (e.g. sex chromosomes).
Hence, variants occuring at such chromosomes exhibit different allele frequencies.
Varlociraptor allows to define this expectation in the calling grammar.
The following example defines the calling for two human samples:

```yaml
samples:
  romeo:
    resolution: 5
    universe:
      all: "0.0 | 0.5 | 1.0"
      X: "0.0 | 1.0"
      Y: "0.0 | 1.0"
  juliet:
    resolution: 5
    universe:
      all: "0.0 | 0.5 | 1.0"
      Y: "0.0"

events:
  both_het: "juliet:0.5 & romeo:0.5"
  both_hom: "juliet:1.0 & romeo:1.0"
  juliet_only: "(juliet:0.5 | juliet:1.0) & romeo:0.0"
  romeo_only: "(romeo:0.5 | romeo:1.0) & juliet:0.0"
```

As can be seen, we define a universe for all chromosomes (`all`), and add exceptions for Romeo (the male) being haploid in the sex chromosomes.
For Juliet (female), the X chromosome is diploid like all other chromosomes, while there is no Y chromosome at all.
Hence, the universe for the Y chromosome becomes `0.0` only.
Currently, Varlociraptor assumes a uniform prior over the defined universes (the grammar will be soon extended to allow other priors as well).
This means that restricting the universe as above also impacts the calculated probabilities for the defined events.
For example, on chromosome Y, there will be no calls for Juliet, because all allele frequencies other than 0.0 will get a probability of zero.
Therefore, all chromosome Y variants will be classified as `romeo_only` or `absent` (the implicit event that none of the samples hosts the variant).

#### FFPE artifact detection

When analyzing formalin-fixed paraffin embedded tissues, one can expect considerable rates of low-frequency C>T and G>A artifacts (see [Do and Dobrovic, Clinical Chemistry 2014](https://doi.org/10.1373/clinchem.2014.223040)).
The variant calling grammar allows to model them as a separate event, allowing to filter them away while considering the involved uncertainty:

```yaml
samples:
  ffpetumor:
    universe: "[0.0,1.0]"
    resolution: 100

events:
  ffpe_artifact: "(C>T | G>A) & ffpetumor:]0.0,0.05["
  present: "((C>T | G>A) & ffpetumor:]0.05,1.0]) | (!(C>T | G>A) & ffpetumor:]0.0,1.0[)"
```

As can be seen, here we introduce an additional type of atomic expression, selecting particular substitutions (e.g. `C>T`, allowed is the [IUPAC DNA alphabet](https://www.bioinformatics.org/sms/iupac.html)).

#### RNA-seq variant calling

When calling variants on RNA-seq, allele frequencies can, although e.g. investigating a diploid sample, take any value from `0.0` to `1.0` again, because we don't know which allele is expressed in what amount.
Of course, this situation can be easily modeled, similar to tumor calling:

```yaml
sample:
  hamletsrna:
    universte: "[0.0,1.0]"
    resolution: 10

events:
  present: "hamletsrna:]0.0,1.0]"
```

RNA-seq variant calling can however suffer from other issues like splicing induced artifacts.
The right way of mapping and processing reads for RNA-seq variant calling is still an area of active research, and we suggest to carefully investigate the current state of the art preprocessing steps, and possible solutions to avoid such artifacts (post-mapping cleanup, mapping against transcriptome, assembly-first, ...).

## Supported variant types

Varlociraptor implements support for all kinds of variants in all length ranges

* SNVs,
* MNVs (multiple nucleotide variants, as called by e.g. Freebayes),
* replacements (small and large),
* Insertions (small and large),
* Deletions (small and large),
* Inversions (small and large),
* Duplications (small and large),
* Breakends.
